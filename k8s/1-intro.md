# 1. 쿠버네티스란

우선 쿠버네티스가 등장하게된 배경에 대해 알아보아야 하는데 간단하게 살펴보자면 가장 큰 이유는 서비스의 배포방식과 가장 관련이 크다고 볼 수 있다.

기존의 대부분의 소프트웨어 애플리케이션은 하나의 프로세스 또는 몇개의 분산된 프로세스로 실행되는 대개 모놀리스(`monolith`)의 구성을 취한다. 이는 구성하기도 비교적 간단하여 오늘날에도 많이 사용되지만

릴리스 주기가 느리거나 비교적 업데이트가 자주 되지 않는다는 점, 또한 배포에 있어서 여러가지 애로사항이 생기는데 이러한 현상을 해결하기 위해 거대한 모니리스 레거시 애플리케이션을 점차 마이크로서비스로 서비스를 분리하기 시작하였다.

여기서 쿠버네티스는 이러한 인프라를 추상화하고 일을 관리하는 역할을 도와준다. 이는 쿠버네티스의 이름의 유래에서도 볼 수 있는데 쿠버네티스는 그리스어로 조정사, 조타수의 의미를 가진다.

# 2. 쿠버네티스와 컨테이너

우선 쿠버네티스는 컨테이너 오캐스트라레이션이라고도 불린다. 이는 컨테이너라는 기술을 사용하여 애플리케이션의 격리를 통해 독립성을 보장하고 이를 쿠버네티스가 관리하기에 컨테이너 오캐스트라레이션이라고 부르는 이유이다.

여기서는 컨테이너를 주로는 다루지 않고 간력하게만 살펴볼것이다. 우선 컨테이너라는 것을 보기전에 기존의 애플리케이션에서 배포하기 전의 문제점은 바로 환경 구성의 통일이다.

개발자의 플랫폼과 프로덕션의 플랫폼이 항상 일치할지 않을 수도 있으며 가령 이러한 환경 구축에 많은 시간이 들어가며 배포에 있어서 애로사항이 생길 수도 있다.

여기서 여러 개발자들은 구성요소에 대해 각각의 환경을 구성해주되 격리된 상황을 만드는 컨테이너 기술에 집중하였다. 컨테이너는 동일한 호스트내에서도 여러 서비스를 실행이 가능하며 이 서비스마다 다른 환경이 구성이 가능하되 서로 격리된다. 심지어 가상머신에 비해서는 성능에 있어 오버헤드또한 적었다.

여기서 이런 컨테이너를 통해 유명한 오픈소스 플랫폼이 있는데 바로 `Docker`이다. (`Docker`이하 도커)는 이러한 컨테이너를 손쉽게 구축 및 배포를 가능하게 만들었으며 컨테이너의 특징인 여러 종속성, 라이브러리가 간단하게 해결이 되니 많은 사람이 이용하게 되었다고 볼 수 있다.

그렇다면 이러한 컨테이너를 이용한다면 앞에서 언급한 마이크로서비스의 단점을 극복이 가능하다고 볼 수 있다. 각각의 프로세스마다 독립된 환경, 컨테이너를 통한 애플리케이션 패키징을 통해 쉽게 배포가 가능하다는 것, 쿠버네티스를 통해 컨테이너를 관리한다면 기존의 마이크로서비스보다 편하게 관리가 가능하다고 본다.

# 3. 쿠버네티스 설치

여러 문서를 본다면 대개 테스트를 위해서는 Minicube를 이용하는데 본 글에서는 rpi4를 이용하여 쿠버네티스를 실습한다. 아마 Minicube나 가상머신을 이용하여 구축하는 것과 별반차이 없을 것으로 예상된다.

구축은 아래의 링크를 통해 참조하고 구축하였다.

https://github.com/codesqueak/k18srpi4

<!-- # 2. 누가 이러한 시스템이 필요한가?

앞에서 간단하게 이야기하였지만 쿠버네티스는 컨테이너 오캐스트라이션, 즉 서비스를 배포 관리를 도와주는 도구이다. 왜 이러한 도구가 필요하게 되었냐를 알아보기 전에는 우선 최근 몇년 동안의 애플리케이션 개발과 배포방식의 변화에 대해서 살펴보는 것이 좋다.

서론에서 대개의 소프트웨어 애플리케이션이 모놀리스에서 마이크로서비스로 변화하고 있ㄷ다고 서술하였는데 이는 인프라환경에 변화가 가장 큰 역할을 하였다.

이는 컨테이너가 등장하면서 더욱 수월하게 이를 가능하게 만들었는데 기존의 모놀리스는 모든것이 강하게 결합되어 있다고 볼 수 있다.

모놀리스의 구성은 전체가 하나의 운영체제 프로세스로 실행되기 때문에 만약 변경이 일어나여 수정이 될때, 전체를 다시 배포해야되는 것과 이러한 상호 의존성이 커지면서 여러 제약과 전체 시스템의 복잡도가 증가한다고 볼 수 있다.

# 3. 마이크로서비스??

여기서 앞에서 언급한 마이크로서비스는 간단하게 설명하자면 서비스를 분활하여 서비스를 구성하는 것인데 이는 서비스간의 통신비용이나 구축하는데 있어서 들어가는 초기비용은 증가할 수 도 있어도 전체 시슨템의 복잡도, 의존성을 낮추는 것이 가능하다.

마이크로서비스는 일반적으로는 `RESTful API`를 제공하는 `HTTP`와 같은 동기 프로토콜과 `AMQP`와 같은 비동기 프로토콜로 통신한다.

이런 프로토콜은 단순하며 개발자가 이해하기 쉬우며, 특정 개발 언어에 대해 종속적이지 않다. 이렇게 정적인 `API`로서 구성된 마이크로서비스는 독립형 프로세스이기 때문에 개별적으로 개발 및 배포가 가능하다.



# 4. 마이크로서비스의 단점

앞에서 언급한 마이크로서비스는 `API`를 통해서 통신하니 서로 독립적이고 안정적으로 보일 수 있다. 다만 이러한 특징이 만드는 단점또한 있는데 마이크로서비스를 배포할 때 전체가 마치 하나의 시스템인것처럼 동작하기 위해 이를 제대로 구성해야 한다는 것이다.

이러한 마이크로서비스의 수가 증가함에 따라 구성 작업의 양은 많아지면 만약 장애가 발생시에는 여러 프로세스와 시스템이 분활되어 있기에 그렇게 쉬운일이 되지 않는다.

또환 환경에 대한 고려도 필요하다. 이는 개발하는 플랫폼과 프로덕션의 플랫폼이 항상일치하지 않을 뿐더러 개발자마다도 환경이 틀릴 수 도 있다. 이는 비단 마이크로서비스의 문제는 아니지만 마이크로서비스의 특성상 이러한 환경 고려또한 단점으로 다가올 수 있다.
# 5. 컨테이너

앞에서 언급한 단점들은 여러 방법으로 해결할 수 있지만 쿠버네티스와 컨테이너를 통해 해결을 할 것이다.

우선 쿠버네티스는 애플리케이션을 격리하는  -->
